// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: beacon.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearBeaconClassroom = `-- name: ClearBeaconClassroom :exec
UPDATE beacons
SET classroom_id = NULL,
    updated_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type ClearBeaconClassroomParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ClearBeaconClassroom(ctx context.Context, arg ClearBeaconClassroomParams) error {
	_, err := q.db.Exec(ctx, clearBeaconClassroom, arg.ID, arg.UpdatedAt)
	return err
}

const createBeacon = `-- name: CreateBeacon :one
INSERT INTO beacons (
  serial_number,
  signature_key,
  totp_key,
  classroom_id,
  program_version,
  created_at,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, serial_number, signature_key, totp_key, classroom_id, program_version, created_at, updated_at, last_seen_at, deleted_at
`

type CreateBeaconParams struct {
	SerialNumber   string             `db:"serial_number" json:"serial_number"`
	SignatureKey   string             `db:"signature_key" json:"signature_key"`
	TotpKey        pgtype.Text        `db:"totp_key" json:"totp_key"`
	ClassroomID    pgtype.UUID        `db:"classroom_id" json:"classroom_id"`
	ProgramVersion pgtype.Text        `db:"program_version" json:"program_version"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateBeacon(ctx context.Context, arg CreateBeaconParams) (Beacon, error) {
	row := q.db.QueryRow(ctx, createBeacon,
		arg.SerialNumber,
		arg.SignatureKey,
		arg.TotpKey,
		arg.ClassroomID,
		arg.ProgramVersion,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Beacon
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SignatureKey,
		&i.TotpKey,
		&i.ClassroomID,
		&i.ProgramVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastSeenAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteBeacon = `-- name: DeleteBeacon :exec
UPDATE beacons
SET deleted_at = $2,
    updated_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteBeaconParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) DeleteBeacon(ctx context.Context, arg DeleteBeaconParams) error {
	_, err := q.db.Exec(ctx, deleteBeacon, arg.ID, arg.DeletedAt)
	return err
}

const getBeacon = `-- name: GetBeacon :one
SELECT id, serial_number, signature_key, totp_key, classroom_id, program_version, created_at, updated_at, last_seen_at, deleted_at
FROM beacons
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetBeacon(ctx context.Context, id pgtype.UUID) (Beacon, error) {
	row := q.db.QueryRow(ctx, getBeacon, id)
	var i Beacon
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SignatureKey,
		&i.TotpKey,
		&i.ClassroomID,
		&i.ProgramVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastSeenAt,
		&i.DeletedAt,
	)
	return i, err
}

const getBeaconBySerial = `-- name: GetBeaconBySerial :one
SELECT id, serial_number, signature_key, totp_key, classroom_id, program_version, created_at, updated_at, last_seen_at, deleted_at
FROM beacons
WHERE serial_number = $1 AND deleted_at IS NULL
`

func (q *Queries) GetBeaconBySerial(ctx context.Context, serialNumber string) (Beacon, error) {
	row := q.db.QueryRow(ctx, getBeaconBySerial, serialNumber)
	var i Beacon
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SignatureKey,
		&i.TotpKey,
		&i.ClassroomID,
		&i.ProgramVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastSeenAt,
		&i.DeletedAt,
	)
	return i, err
}

const listBeacons = `-- name: ListBeacons :many
SELECT id, serial_number, signature_key, totp_key, classroom_id, program_version, created_at, updated_at, last_seen_at, deleted_at
FROM beacons
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListBeacons(ctx context.Context, limit int32) ([]Beacon, error) {
	rows, err := q.db.Query(ctx, listBeacons, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Beacon
	for rows.Next() {
		var i Beacon
		if err := rows.Scan(
			&i.ID,
			&i.SerialNumber,
			&i.SignatureKey,
			&i.TotpKey,
			&i.ClassroomID,
			&i.ProgramVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastSeenAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeaconsByClassroom = `-- name: ListBeaconsByClassroom :many
SELECT id, serial_number, signature_key, totp_key, classroom_id, program_version, created_at, updated_at, last_seen_at, deleted_at
FROM beacons
WHERE classroom_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListBeaconsByClassroom(ctx context.Context, classroomID pgtype.UUID) ([]Beacon, error) {
	rows, err := q.db.Query(ctx, listBeaconsByClassroom, classroomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Beacon
	for rows.Next() {
		var i Beacon
		if err := rows.Scan(
			&i.ID,
			&i.SerialNumber,
			&i.SignatureKey,
			&i.TotpKey,
			&i.ClassroomID,
			&i.ProgramVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastSeenAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBeacon = `-- name: UpdateBeacon :one
UPDATE beacons
SET serial_number = COALESCE($2, serial_number),
    totp_key = COALESCE($3, totp_key),
    classroom_id = COALESCE($4, classroom_id),
    program_version = COALESCE($5, program_version),
    updated_at = $6
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, serial_number, signature_key, totp_key, classroom_id, program_version, created_at, updated_at, last_seen_at, deleted_at
`

type UpdateBeaconParams struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	SerialNumber   string             `db:"serial_number" json:"serial_number"`
	TotpKey        pgtype.Text        `db:"totp_key" json:"totp_key"`
	ClassroomID    pgtype.UUID        `db:"classroom_id" json:"classroom_id"`
	ProgramVersion pgtype.Text        `db:"program_version" json:"program_version"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateBeacon(ctx context.Context, arg UpdateBeaconParams) (Beacon, error) {
	row := q.db.QueryRow(ctx, updateBeacon,
		arg.ID,
		arg.SerialNumber,
		arg.TotpKey,
		arg.ClassroomID,
		arg.ProgramVersion,
		arg.UpdatedAt,
	)
	var i Beacon
	err := row.Scan(
		&i.ID,
		&i.SerialNumber,
		&i.SignatureKey,
		&i.TotpKey,
		&i.ClassroomID,
		&i.ProgramVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastSeenAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateBeaconClassroom = `-- name: UpdateBeaconClassroom :exec
UPDATE beacons
SET classroom_id = $2,
    updated_at = $3
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateBeaconClassroomParams struct {
	ID          pgtype.UUID        `db:"id" json:"id"`
	ClassroomID pgtype.UUID        `db:"classroom_id" json:"classroom_id"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateBeaconClassroom(ctx context.Context, arg UpdateBeaconClassroomParams) error {
	_, err := q.db.Exec(ctx, updateBeaconClassroom, arg.ID, arg.ClassroomID, arg.UpdatedAt)
	return err
}

const updateBeaconLastSeen = `-- name: UpdateBeaconLastSeen :exec
UPDATE beacons
SET last_seen_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateBeaconLastSeenParams struct {
	ID         pgtype.UUID        `db:"id" json:"id"`
	LastSeenAt pgtype.Timestamptz `db:"last_seen_at" json:"last_seen_at"`
}

func (q *Queries) UpdateBeaconLastSeen(ctx context.Context, arg UpdateBeaconLastSeenParams) error {
	_, err := q.db.Exec(ctx, updateBeaconLastSeen, arg.ID, arg.LastSeenAt)
	return err
}

const updateBeaconTOTP = `-- name: UpdateBeaconTOTP :exec
UPDATE beacons
SET totp_key = $2,
    updated_at = $3
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateBeaconTOTPParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	TotpKey   pgtype.Text        `db:"totp_key" json:"totp_key"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateBeaconTOTP(ctx context.Context, arg UpdateBeaconTOTPParams) error {
	_, err := q.db.Exec(ctx, updateBeaconTOTP, arg.ID, arg.TotpKey, arg.UpdatedAt)
	return err
}
