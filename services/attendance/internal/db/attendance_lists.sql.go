// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attendance_lists.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStudentSignatureStatusByCourse = `-- name: CountStudentSignatureStatusByCourse :many
SELECT s.status, COUNT(*) AS total
FROM signatures s
INNER JOIN student_signatures ss ON ss.signature_id = s.id
WHERE s.course_id = $1
  AND s.deleted_at IS NULL
GROUP BY s.status
`

type CountStudentSignatureStatusByCourseRow struct {
	Status SignatureStatus `db:"status" json:"status"`
	Total  int64           `db:"total" json:"total"`
}

func (q *Queries) CountStudentSignatureStatusByCourse(ctx context.Context, courseID pgtype.UUID) ([]CountStudentSignatureStatusByCourseRow, error) {
	rows, err := q.db.Query(ctx, countStudentSignatureStatusByCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountStudentSignatureStatusByCourseRow
	for rows.Next() {
		var i CountStudentSignatureStatusByCourseRow
		if err := rows.Scan(&i.Status, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countTeacherSignaturesByCourse = `-- name: CountTeacherSignaturesByCourse :one
SELECT COUNT(*) AS total
FROM signatures s
INNER JOIN teacher_signatures ts ON ts.signature_id = s.id
WHERE s.course_id = $1
  AND s.deleted_at IS NULL
`

func (q *Queries) CountTeacherSignaturesByCourse(ctx context.Context, courseID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTeacherSignaturesByCourse, courseID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const hasTeacherPresence = `-- name: HasTeacherPresence :one
SELECT EXISTS (
  SELECT 1
  FROM signatures s
  INNER JOIN teacher_signatures ts ON ts.signature_id = s.id
  WHERE s.course_id = $1
    AND s.deleted_at IS NULL
    AND s.status IN ('present', 'signed')
) AS is_present
`

func (q *Queries) HasTeacherPresence(ctx context.Context, courseID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasTeacherPresence, courseID)
	var is_present bool
	err := row.Scan(&is_present)
	return is_present, err
}

const listStudentSignaturesByCourse = `-- name: ListStudentSignaturesByCourse :many
SELECT s.id,
       s.course_id,
       s.signed_at,
       s.status,
       s.method,
       s.image_url,
       s.created_at,
       s.updated_at,
       s.deleted_at,
       ss.student_id,
       ss.teacher_id,
       ss.administrator_id
FROM signatures s
INNER JOIN student_signatures ss ON ss.signature_id = s.id
WHERE s.course_id = $1
  AND s.deleted_at IS NULL
ORDER BY s.signed_at DESC
LIMIT $2
`

type ListStudentSignaturesByCourseParams struct {
	CourseID pgtype.UUID `db:"course_id" json:"course_id"`
	Limit    int32       `db:"limit" json:"limit"`
}

type ListStudentSignaturesByCourseRow struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	CourseID        pgtype.UUID        `db:"course_id" json:"course_id"`
	SignedAt        pgtype.Timestamptz `db:"signed_at" json:"signed_at"`
	Status          SignatureStatus    `db:"status" json:"status"`
	Method          SignatureMethod    `db:"method" json:"method"`
	ImageUrl        pgtype.Text        `db:"image_url" json:"image_url"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	StudentID       pgtype.UUID        `db:"student_id" json:"student_id"`
	TeacherID       pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	AdministratorID pgtype.UUID        `db:"administrator_id" json:"administrator_id"`
}

func (q *Queries) ListStudentSignaturesByCourse(ctx context.Context, arg ListStudentSignaturesByCourseParams) ([]ListStudentSignaturesByCourseRow, error) {
	rows, err := q.db.Query(ctx, listStudentSignaturesByCourse, arg.CourseID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStudentSignaturesByCourseRow
	for rows.Next() {
		var i ListStudentSignaturesByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.SignedAt,
			&i.Status,
			&i.Method,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.StudentID,
			&i.TeacherID,
			&i.AdministratorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentSignaturesByStudent = `-- name: ListStudentSignaturesByStudent :many
SELECT s.id,
       s.course_id,
       s.signed_at,
       s.status,
       s.method,
       s.image_url,
       s.created_at,
       s.updated_at,
       s.deleted_at,
       ss.student_id,
       ss.teacher_id,
       ss.administrator_id
FROM signatures s
INNER JOIN student_signatures ss ON ss.signature_id = s.id
WHERE ss.student_id = $1
  AND s.deleted_at IS NULL
ORDER BY s.signed_at DESC
LIMIT $2
`

type ListStudentSignaturesByStudentParams struct {
	StudentID pgtype.UUID `db:"student_id" json:"student_id"`
	Limit     int32       `db:"limit" json:"limit"`
}

type ListStudentSignaturesByStudentRow struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	CourseID        pgtype.UUID        `db:"course_id" json:"course_id"`
	SignedAt        pgtype.Timestamptz `db:"signed_at" json:"signed_at"`
	Status          SignatureStatus    `db:"status" json:"status"`
	Method          SignatureMethod    `db:"method" json:"method"`
	ImageUrl        pgtype.Text        `db:"image_url" json:"image_url"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	StudentID       pgtype.UUID        `db:"student_id" json:"student_id"`
	TeacherID       pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	AdministratorID pgtype.UUID        `db:"administrator_id" json:"administrator_id"`
}

func (q *Queries) ListStudentSignaturesByStudent(ctx context.Context, arg ListStudentSignaturesByStudentParams) ([]ListStudentSignaturesByStudentRow, error) {
	rows, err := q.db.Query(ctx, listStudentSignaturesByStudent, arg.StudentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStudentSignaturesByStudentRow
	for rows.Next() {
		var i ListStudentSignaturesByStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.SignedAt,
			&i.Status,
			&i.Method,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.StudentID,
			&i.TeacherID,
			&i.AdministratorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentSignaturesByStudentAndCourse = `-- name: ListStudentSignaturesByStudentAndCourse :many
SELECT s.id,
       s.course_id,
       s.signed_at,
       s.status,
       s.method,
       s.image_url,
       s.created_at,
       s.updated_at,
       s.deleted_at,
       ss.student_id,
       ss.teacher_id,
       ss.administrator_id
FROM signatures s
INNER JOIN student_signatures ss ON ss.signature_id = s.id
WHERE ss.student_id = $1
  AND s.course_id = $2
  AND s.deleted_at IS NULL
ORDER BY s.signed_at DESC
LIMIT $3
`

type ListStudentSignaturesByStudentAndCourseParams struct {
	StudentID pgtype.UUID `db:"student_id" json:"student_id"`
	CourseID  pgtype.UUID `db:"course_id" json:"course_id"`
	Limit     int32       `db:"limit" json:"limit"`
}

type ListStudentSignaturesByStudentAndCourseRow struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	CourseID        pgtype.UUID        `db:"course_id" json:"course_id"`
	SignedAt        pgtype.Timestamptz `db:"signed_at" json:"signed_at"`
	Status          SignatureStatus    `db:"status" json:"status"`
	Method          SignatureMethod    `db:"method" json:"method"`
	ImageUrl        pgtype.Text        `db:"image_url" json:"image_url"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	StudentID       pgtype.UUID        `db:"student_id" json:"student_id"`
	TeacherID       pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	AdministratorID pgtype.UUID        `db:"administrator_id" json:"administrator_id"`
}

func (q *Queries) ListStudentSignaturesByStudentAndCourse(ctx context.Context, arg ListStudentSignaturesByStudentAndCourseParams) ([]ListStudentSignaturesByStudentAndCourseRow, error) {
	rows, err := q.db.Query(ctx, listStudentSignaturesByStudentAndCourse, arg.StudentID, arg.CourseID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStudentSignaturesByStudentAndCourseRow
	for rows.Next() {
		var i ListStudentSignaturesByStudentAndCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.SignedAt,
			&i.Status,
			&i.Method,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.StudentID,
			&i.TeacherID,
			&i.AdministratorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeacherSignaturesByCourse = `-- name: ListTeacherSignaturesByCourse :many
SELECT s.id,
       s.course_id,
       s.signed_at,
       s.status,
       s.method,
       s.image_url,
       s.created_at,
       s.updated_at,
       s.deleted_at,
       ts.teacher_id,
       ts.administrator_id
FROM signatures s
INNER JOIN teacher_signatures ts ON ts.signature_id = s.id
WHERE s.course_id = $1
  AND s.deleted_at IS NULL
ORDER BY s.signed_at DESC
LIMIT $2
`

type ListTeacherSignaturesByCourseParams struct {
	CourseID pgtype.UUID `db:"course_id" json:"course_id"`
	Limit    int32       `db:"limit" json:"limit"`
}

type ListTeacherSignaturesByCourseRow struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	CourseID        pgtype.UUID        `db:"course_id" json:"course_id"`
	SignedAt        pgtype.Timestamptz `db:"signed_at" json:"signed_at"`
	Status          SignatureStatus    `db:"status" json:"status"`
	Method          SignatureMethod    `db:"method" json:"method"`
	ImageUrl        pgtype.Text        `db:"image_url" json:"image_url"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	TeacherID       pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	AdministratorID pgtype.UUID        `db:"administrator_id" json:"administrator_id"`
}

func (q *Queries) ListTeacherSignaturesByCourse(ctx context.Context, arg ListTeacherSignaturesByCourseParams) ([]ListTeacherSignaturesByCourseRow, error) {
	rows, err := q.db.Query(ctx, listTeacherSignaturesByCourse, arg.CourseID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeacherSignaturesByCourseRow
	for rows.Next() {
		var i ListTeacherSignaturesByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.SignedAt,
			&i.Status,
			&i.Method,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TeacherID,
			&i.AdministratorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeacherSignaturesByTeacher = `-- name: ListTeacherSignaturesByTeacher :many
SELECT s.id,
       s.course_id,
       s.signed_at,
       s.status,
       s.method,
       s.image_url,
       s.created_at,
       s.updated_at,
       s.deleted_at,
       ts.teacher_id,
       ts.administrator_id
FROM signatures s
INNER JOIN teacher_signatures ts ON ts.signature_id = s.id
WHERE ts.teacher_id = $1
  AND s.deleted_at IS NULL
ORDER BY s.signed_at DESC
LIMIT $2
`

type ListTeacherSignaturesByTeacherParams struct {
	TeacherID pgtype.UUID `db:"teacher_id" json:"teacher_id"`
	Limit     int32       `db:"limit" json:"limit"`
}

type ListTeacherSignaturesByTeacherRow struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	CourseID        pgtype.UUID        `db:"course_id" json:"course_id"`
	SignedAt        pgtype.Timestamptz `db:"signed_at" json:"signed_at"`
	Status          SignatureStatus    `db:"status" json:"status"`
	Method          SignatureMethod    `db:"method" json:"method"`
	ImageUrl        pgtype.Text        `db:"image_url" json:"image_url"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	TeacherID       pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	AdministratorID pgtype.UUID        `db:"administrator_id" json:"administrator_id"`
}

func (q *Queries) ListTeacherSignaturesByTeacher(ctx context.Context, arg ListTeacherSignaturesByTeacherParams) ([]ListTeacherSignaturesByTeacherRow, error) {
	rows, err := q.db.Query(ctx, listTeacherSignaturesByTeacher, arg.TeacherID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeacherSignaturesByTeacherRow
	for rows.Next() {
		var i ListTeacherSignaturesByTeacherRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.SignedAt,
			&i.Status,
			&i.Method,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TeacherID,
			&i.AdministratorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeacherSignaturesByTeacherAndCourse = `-- name: ListTeacherSignaturesByTeacherAndCourse :many
SELECT s.id,
       s.course_id,
       s.signed_at,
       s.status,
       s.method,
       s.image_url,
       s.created_at,
       s.updated_at,
       s.deleted_at,
       ts.teacher_id,
       ts.administrator_id
FROM signatures s
INNER JOIN teacher_signatures ts ON ts.signature_id = s.id
WHERE ts.teacher_id = $1
  AND s.course_id = $2
  AND s.deleted_at IS NULL
ORDER BY s.signed_at DESC
LIMIT $3
`

type ListTeacherSignaturesByTeacherAndCourseParams struct {
	TeacherID pgtype.UUID `db:"teacher_id" json:"teacher_id"`
	CourseID  pgtype.UUID `db:"course_id" json:"course_id"`
	Limit     int32       `db:"limit" json:"limit"`
}

type ListTeacherSignaturesByTeacherAndCourseRow struct {
	ID              pgtype.UUID        `db:"id" json:"id"`
	CourseID        pgtype.UUID        `db:"course_id" json:"course_id"`
	SignedAt        pgtype.Timestamptz `db:"signed_at" json:"signed_at"`
	Status          SignatureStatus    `db:"status" json:"status"`
	Method          SignatureMethod    `db:"method" json:"method"`
	ImageUrl        pgtype.Text        `db:"image_url" json:"image_url"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	TeacherID       pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	AdministratorID pgtype.UUID        `db:"administrator_id" json:"administrator_id"`
}

func (q *Queries) ListTeacherSignaturesByTeacherAndCourse(ctx context.Context, arg ListTeacherSignaturesByTeacherAndCourseParams) ([]ListTeacherSignaturesByTeacherAndCourseRow, error) {
	rows, err := q.db.Query(ctx, listTeacherSignaturesByTeacherAndCourse, arg.TeacherID, arg.CourseID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeacherSignaturesByTeacherAndCourseRow
	for rows.Next() {
		var i ListTeacherSignaturesByTeacherAndCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.SignedAt,
			&i.Status,
			&i.Method,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TeacherID,
			&i.AdministratorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
