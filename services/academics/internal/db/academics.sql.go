// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: academics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCourseClassroom = `-- name: AddCourseClassroom :exec
INSERT INTO courses_classrooms (id, course_id, classroom_id, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (course_id, classroom_id) DO NOTHING
`

type AddCourseClassroomParams struct {
	ID          pgtype.UUID        `db:"id" json:"id"`
	CourseID    pgtype.UUID        `db:"course_id" json:"course_id"`
	ClassroomID pgtype.UUID        `db:"classroom_id" json:"classroom_id"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) AddCourseClassroom(ctx context.Context, arg AddCourseClassroomParams) error {
	_, err := q.db.Exec(ctx, addCourseClassroom,
		arg.ID,
		arg.CourseID,
		arg.ClassroomID,
		arg.CreatedAt,
	)
	return err
}

const addCourseStudentGroup = `-- name: AddCourseStudentGroup :exec
INSERT INTO courses_student_groups (id, course_id, student_group_id, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (course_id, student_group_id) DO NOTHING
`

type AddCourseStudentGroupParams struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	CourseID       pgtype.UUID        `db:"course_id" json:"course_id"`
	StudentGroupID pgtype.UUID        `db:"student_group_id" json:"student_group_id"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) AddCourseStudentGroup(ctx context.Context, arg AddCourseStudentGroupParams) error {
	_, err := q.db.Exec(ctx, addCourseStudentGroup,
		arg.ID,
		arg.CourseID,
		arg.StudentGroupID,
		arg.CreatedAt,
	)
	return err
}

const addCourseTeacher = `-- name: AddCourseTeacher :exec
INSERT INTO teachers_courses (id, teacher_id, course_id, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (teacher_id, course_id) DO NOTHING
`

type AddCourseTeacherParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	TeacherID pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	CourseID  pgtype.UUID        `db:"course_id" json:"course_id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) AddCourseTeacher(ctx context.Context, arg AddCourseTeacherParams) error {
	_, err := q.db.Exec(ctx, addCourseTeacher,
		arg.ID,
		arg.TeacherID,
		arg.CourseID,
		arg.CreatedAt,
	)
	return err
}

const addStudentGroupMembers = `-- name: AddStudentGroupMembers :exec
INSERT INTO students_groups (id, student_id, student_group_id, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (student_id, student_group_id) DO NOTHING
`

type AddStudentGroupMembersParams struct {
	ID             pgtype.UUID        `db:"id" json:"id"`
	StudentID      pgtype.UUID        `db:"student_id" json:"student_id"`
	StudentGroupID pgtype.UUID        `db:"student_group_id" json:"student_group_id"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) AddStudentGroupMembers(ctx context.Context, arg AddStudentGroupMembersParams) error {
	_, err := q.db.Exec(ctx, addStudentGroupMembers,
		arg.ID,
		arg.StudentID,
		arg.StudentGroupID,
		arg.CreatedAt,
	)
	return err
}

const createClassroom = `-- name: CreateClassroom :one
INSERT INTO classrooms (id, school_id, name, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, school_id, name, created_at, updated_at, deleted_at
`

type CreateClassroomParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	SchoolID  pgtype.UUID        `db:"school_id" json:"school_id"`
	Name      string             `db:"name" json:"name"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateClassroom(ctx context.Context, arg CreateClassroomParams) (Classroom, error) {
	row := q.db.QueryRow(ctx, createClassroom,
		arg.ID,
		arg.SchoolID,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Classroom
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createCourse = `-- name: CreateCourse :one
INSERT INTO courses (
  id,
  school_id,
  name,
  start_at,
  end_at,
  is_online,
  signature_closing_delay_minutes,
  signature_closed,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10
)
RETURNING id, school_id, name, start_at, end_at, is_online, signature_closing_delay_minutes, signature_closed, created_at, updated_at, deleted_at
`

type CreateCourseParams struct {
	ID                           pgtype.UUID        `db:"id" json:"id"`
	SchoolID                     pgtype.UUID        `db:"school_id" json:"school_id"`
	Name                         string             `db:"name" json:"name"`
	StartAt                      pgtype.Timestamptz `db:"start_at" json:"start_at"`
	EndAt                        pgtype.Timestamptz `db:"end_at" json:"end_at"`
	IsOnline                     bool               `db:"is_online" json:"is_online"`
	SignatureClosingDelayMinutes int32              `db:"signature_closing_delay_minutes" json:"signature_closing_delay_minutes"`
	SignatureClosed              bool               `db:"signature_closed" json:"signature_closed"`
	CreatedAt                    pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, createCourse,
		arg.ID,
		arg.SchoolID,
		arg.Name,
		arg.StartAt,
		arg.EndAt,
		arg.IsOnline,
		arg.SignatureClosingDelayMinutes,
		arg.SignatureClosed,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.StartAt,
		&i.EndAt,
		&i.IsOnline,
		&i.SignatureClosingDelayMinutes,
		&i.SignatureClosed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSchool = `-- name: CreateSchool :one
INSERT INTO schools (id, name, preferences_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, preferences_id, created_at, updated_at, deleted_at
`

type CreateSchoolParams struct {
	ID            pgtype.UUID        `db:"id" json:"id"`
	Name          string             `db:"name" json:"name"`
	PreferencesID pgtype.UUID        `db:"preferences_id" json:"preferences_id"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateSchool(ctx context.Context, arg CreateSchoolParams) (School, error) {
	row := q.db.QueryRow(ctx, createSchool,
		arg.ID,
		arg.Name,
		arg.PreferencesID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i School
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PreferencesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSchoolPreferences = `-- name: CreateSchoolPreferences :one
INSERT INTO school_preferences (
  id,
  default_signature_closing_delay_minutes,
  teacher_can_modify_closing_delay,
  students_can_sign_before_teacher,
  enable_flash,
  enable_qrcode,
  enable_nfc,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
) RETURNING id, default_signature_closing_delay_minutes, teacher_can_modify_closing_delay, students_can_sign_before_teacher, enable_flash, enable_qrcode, enable_nfc, created_at, updated_at, deleted_at
`

type CreateSchoolPreferencesParams struct {
	ID                                  pgtype.UUID        `db:"id" json:"id"`
	DefaultSignatureClosingDelayMinutes int32              `db:"default_signature_closing_delay_minutes" json:"default_signature_closing_delay_minutes"`
	TeacherCanModifyClosingDelay        bool               `db:"teacher_can_modify_closing_delay" json:"teacher_can_modify_closing_delay"`
	StudentsCanSignBeforeTeacher        bool               `db:"students_can_sign_before_teacher" json:"students_can_sign_before_teacher"`
	EnableFlash                         bool               `db:"enable_flash" json:"enable_flash"`
	EnableQrcode                        bool               `db:"enable_qrcode" json:"enable_qrcode"`
	EnableNfc                           bool               `db:"enable_nfc" json:"enable_nfc"`
	CreatedAt                           pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt                           pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateSchoolPreferences(ctx context.Context, arg CreateSchoolPreferencesParams) (SchoolPreference, error) {
	row := q.db.QueryRow(ctx, createSchoolPreferences,
		arg.ID,
		arg.DefaultSignatureClosingDelayMinutes,
		arg.TeacherCanModifyClosingDelay,
		arg.StudentsCanSignBeforeTeacher,
		arg.EnableFlash,
		arg.EnableQrcode,
		arg.EnableNfc,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SchoolPreference
	err := row.Scan(
		&i.ID,
		&i.DefaultSignatureClosingDelayMinutes,
		&i.TeacherCanModifyClosingDelay,
		&i.StudentsCanSignBeforeTeacher,
		&i.EnableFlash,
		&i.EnableQrcode,
		&i.EnableNfc,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createStudentGroup = `-- name: CreateStudentGroup :one
INSERT INTO student_groups (id, school_id, name, single_student_group, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, school_id, name, single_student_group, created_at, updated_at, deleted_at
`

type CreateStudentGroupParams struct {
	ID                 pgtype.UUID        `db:"id" json:"id"`
	SchoolID           pgtype.UUID        `db:"school_id" json:"school_id"`
	Name               string             `db:"name" json:"name"`
	SingleStudentGroup bool               `db:"single_student_group" json:"single_student_group"`
	CreatedAt          pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateStudentGroup(ctx context.Context, arg CreateStudentGroupParams) (StudentGroup, error) {
	row := q.db.QueryRow(ctx, createStudentGroup,
		arg.ID,
		arg.SchoolID,
		arg.Name,
		arg.SingleStudentGroup,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i StudentGroup
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.SingleStudentGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClassroom = `-- name: GetClassroom :one
SELECT id, school_id, name, created_at, updated_at, deleted_at
FROM classrooms
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetClassroom(ctx context.Context, id pgtype.UUID) (Classroom, error) {
	row := q.db.QueryRow(ctx, getClassroom, id)
	var i Classroom
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCourse = `-- name: GetCourse :one
SELECT id, school_id, name, start_at, end_at, is_online, signature_closing_delay_minutes, signature_closed, created_at, updated_at, deleted_at
FROM courses
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCourse(ctx context.Context, id pgtype.UUID) (Course, error) {
	row := q.db.QueryRow(ctx, getCourse, id)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.StartAt,
		&i.EndAt,
		&i.IsOnline,
		&i.SignatureClosingDelayMinutes,
		&i.SignatureClosed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSchool = `-- name: GetSchool :one
SELECT id, name, preferences_id, created_at, updated_at, deleted_at
FROM schools
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSchool(ctx context.Context, id pgtype.UUID) (School, error) {
	row := q.db.QueryRow(ctx, getSchool, id)
	var i School
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PreferencesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSchoolPreferences = `-- name: GetSchoolPreferences :one
SELECT id, default_signature_closing_delay_minutes, teacher_can_modify_closing_delay, students_can_sign_before_teacher, enable_flash, enable_qrcode, enable_nfc, created_at, updated_at, deleted_at
FROM school_preferences
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSchoolPreferences(ctx context.Context, id pgtype.UUID) (SchoolPreference, error) {
	row := q.db.QueryRow(ctx, getSchoolPreferences, id)
	var i SchoolPreference
	err := row.Scan(
		&i.ID,
		&i.DefaultSignatureClosingDelayMinutes,
		&i.TeacherCanModifyClosingDelay,
		&i.StudentsCanSignBeforeTeacher,
		&i.EnableFlash,
		&i.EnableQrcode,
		&i.EnableNfc,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStudentGroup = `-- name: GetStudentGroup :one
SELECT id, school_id, name, single_student_group, created_at, updated_at, deleted_at
FROM student_groups
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetStudentGroup(ctx context.Context, id pgtype.UUID) (StudentGroup, error) {
	row := q.db.QueryRow(ctx, getStudentGroup, id)
	var i StudentGroup
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.SingleStudentGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listClassroomsByCourse = `-- name: ListClassroomsByCourse :many
SELECT c.id, c.school_id, c.name, c.created_at, c.updated_at, c.deleted_at
FROM classrooms c
INNER JOIN courses_classrooms cc ON cc.classroom_id = c.id
WHERE cc.course_id = $1 AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
`

func (q *Queries) ListClassroomsByCourse(ctx context.Context, courseID pgtype.UUID) ([]Classroom, error) {
	rows, err := q.db.Query(ctx, listClassroomsByCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Classroom
	for rows.Next() {
		var i Classroom
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClassroomsBySchool = `-- name: ListClassroomsBySchool :many
SELECT id, school_id, name, created_at, updated_at, deleted_at
FROM classrooms
WHERE school_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
`

type ListClassroomsBySchoolParams struct {
	SchoolID pgtype.UUID `db:"school_id" json:"school_id"`
	Limit    int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListClassroomsBySchool(ctx context.Context, arg ListClassroomsBySchoolParams) ([]Classroom, error) {
	rows, err := q.db.Query(ctx, listClassroomsBySchool, arg.SchoolID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Classroom
	for rows.Next() {
		var i Classroom
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesBySchool = `-- name: ListCoursesBySchool :many
SELECT id, school_id, name, start_at, end_at, is_online, signature_closing_delay_minutes, signature_closed, created_at, updated_at, deleted_at
FROM courses
WHERE school_id = $1 AND deleted_at IS NULL
ORDER BY start_at DESC
LIMIT $2
`

type ListCoursesBySchoolParams struct {
	SchoolID pgtype.UUID `db:"school_id" json:"school_id"`
	Limit    int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListCoursesBySchool(ctx context.Context, arg ListCoursesBySchoolParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesBySchool, arg.SchoolID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesBySchoolWithinRange = `-- name: ListCoursesBySchoolWithinRange :many
SELECT id, school_id, name, start_at, end_at, is_online, signature_closing_delay_minutes, signature_closed, created_at, updated_at, deleted_at
FROM courses
WHERE school_id = $1
  AND deleted_at IS NULL
  AND start_at::date BETWEEN $2 AND $3
ORDER BY start_at DESC
LIMIT $4
`

type ListCoursesBySchoolWithinRangeParams struct {
	SchoolID  pgtype.UUID        `db:"school_id" json:"school_id"`
	StartAt   pgtype.Timestamptz `db:"start_at" json:"start_at"`
	StartAt_2 pgtype.Timestamptz `db:"start_at_2" json:"start_at_2"`
	Limit     int32              `db:"limit" json:"limit"`
}

func (q *Queries) ListCoursesBySchoolWithinRange(ctx context.Context, arg ListCoursesBySchoolWithinRangeParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesBySchoolWithinRange,
		arg.SchoolID,
		arg.StartAt,
		arg.StartAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesByStudent = `-- name: ListCoursesByStudent :many
SELECT c.id, c.school_id, c.name, c.start_at, c.end_at, c.is_online, c.signature_closing_delay_minutes, c.signature_closed, c.created_at, c.updated_at, c.deleted_at
FROM courses c
INNER JOIN courses_student_groups csg ON csg.course_id = c.id
INNER JOIN students_groups sg ON sg.student_group_id = csg.student_group_id
WHERE sg.student_id = $1 AND c.deleted_at IS NULL
ORDER BY c.start_at DESC
LIMIT $2
`

type ListCoursesByStudentParams struct {
	StudentID pgtype.UUID `db:"student_id" json:"student_id"`
	Limit     int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListCoursesByStudent(ctx context.Context, arg ListCoursesByStudentParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesByStudent, arg.StudentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesByStudentGroup = `-- name: ListCoursesByStudentGroup :many
SELECT c.id, c.school_id, c.name, c.start_at, c.end_at, c.is_online, c.signature_closing_delay_minutes, c.signature_closed, c.created_at, c.updated_at, c.deleted_at
FROM courses c
INNER JOIN courses_student_groups csg ON csg.course_id = c.id
WHERE csg.student_group_id = $1 AND c.deleted_at IS NULL
ORDER BY c.start_at DESC
`

func (q *Queries) ListCoursesByStudentGroup(ctx context.Context, studentGroupID pgtype.UUID) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesByStudentGroup, studentGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesByStudentWithinRange = `-- name: ListCoursesByStudentWithinRange :many
SELECT c.id, c.school_id, c.name, c.start_at, c.end_at, c.is_online, c.signature_closing_delay_minutes, c.signature_closed, c.created_at, c.updated_at, c.deleted_at
FROM courses c
INNER JOIN courses_student_groups csg ON csg.course_id = c.id
INNER JOIN students_groups sg ON sg.student_group_id = csg.student_group_id
WHERE sg.student_id = $1
  AND c.deleted_at IS NULL
  AND c.start_at::date BETWEEN $2 AND $3
ORDER BY c.start_at DESC
LIMIT $4
`

type ListCoursesByStudentWithinRangeParams struct {
	StudentID pgtype.UUID        `db:"student_id" json:"student_id"`
	StartAt   pgtype.Timestamptz `db:"start_at" json:"start_at"`
	StartAt_2 pgtype.Timestamptz `db:"start_at_2" json:"start_at_2"`
	Limit     int32              `db:"limit" json:"limit"`
}

func (q *Queries) ListCoursesByStudentWithinRange(ctx context.Context, arg ListCoursesByStudentWithinRangeParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesByStudentWithinRange,
		arg.StudentID,
		arg.StartAt,
		arg.StartAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesByTeacher = `-- name: ListCoursesByTeacher :many
SELECT c.id, c.school_id, c.name, c.start_at, c.end_at, c.is_online, c.signature_closing_delay_minutes, c.signature_closed, c.created_at, c.updated_at, c.deleted_at
FROM courses c
INNER JOIN teachers_courses tc ON tc.course_id = c.id
WHERE tc.teacher_id = $1 AND c.deleted_at IS NULL
ORDER BY c.start_at DESC
LIMIT $2
`

type ListCoursesByTeacherParams struct {
	TeacherID pgtype.UUID `db:"teacher_id" json:"teacher_id"`
	Limit     int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListCoursesByTeacher(ctx context.Context, arg ListCoursesByTeacherParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesByTeacher, arg.TeacherID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesByTeacherWithinRange = `-- name: ListCoursesByTeacherWithinRange :many
SELECT c.id, c.school_id, c.name, c.start_at, c.end_at, c.is_online, c.signature_closing_delay_minutes, c.signature_closed, c.created_at, c.updated_at, c.deleted_at
FROM courses c
INNER JOIN teachers_courses tc ON tc.course_id = c.id
WHERE tc.teacher_id = $1
  AND c.deleted_at IS NULL
  AND c.start_at::date BETWEEN $2 AND $3
ORDER BY c.start_at DESC
LIMIT $4
`

type ListCoursesByTeacherWithinRangeParams struct {
	TeacherID pgtype.UUID        `db:"teacher_id" json:"teacher_id"`
	StartAt   pgtype.Timestamptz `db:"start_at" json:"start_at"`
	StartAt_2 pgtype.Timestamptz `db:"start_at_2" json:"start_at_2"`
	Limit     int32              `db:"limit" json:"limit"`
}

func (q *Queries) ListCoursesByTeacherWithinRange(ctx context.Context, arg ListCoursesByTeacherWithinRangeParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCoursesByTeacherWithinRange,
		arg.TeacherID,
		arg.StartAt,
		arg.StartAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.StartAt,
			&i.EndAt,
			&i.IsOnline,
			&i.SignatureClosingDelayMinutes,
			&i.SignatureClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchedStudentCourseGroups = `-- name: ListMatchedStudentCourseGroups :many
SELECT csg.student_group_id
FROM courses_student_groups csg
INNER JOIN students_groups sg ON sg.student_group_id = csg.student_group_id
WHERE sg.student_id = $1 AND csg.course_id = $2
`

type ListMatchedStudentCourseGroupsParams struct {
	StudentID pgtype.UUID `db:"student_id" json:"student_id"`
	CourseID  pgtype.UUID `db:"course_id" json:"course_id"`
}

func (q *Queries) ListMatchedStudentCourseGroups(ctx context.Context, arg ListMatchedStudentCourseGroupsParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listMatchedStudentCourseGroups, arg.StudentID, arg.CourseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var student_group_id pgtype.UUID
		if err := rows.Scan(&student_group_id); err != nil {
			return nil, err
		}
		items = append(items, student_group_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchools = `-- name: ListSchools :many
SELECT id, name, preferences_id, created_at, updated_at, deleted_at
FROM schools
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListSchools(ctx context.Context, limit int32) ([]School, error) {
	rows, err := q.db.Query(ctx, listSchools, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []School
	for rows.Next() {
		var i School
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PreferencesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentGroupsBySchool = `-- name: ListStudentGroupsBySchool :many
SELECT id, school_id, name, single_student_group, created_at, updated_at, deleted_at
FROM student_groups
WHERE school_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
`

type ListStudentGroupsBySchoolParams struct {
	SchoolID pgtype.UUID `db:"school_id" json:"school_id"`
	Limit    int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListStudentGroupsBySchool(ctx context.Context, arg ListStudentGroupsBySchoolParams) ([]StudentGroup, error) {
	rows, err := q.db.Query(ctx, listStudentGroupsBySchool, arg.SchoolID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentGroup
	for rows.Next() {
		var i StudentGroup
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Name,
			&i.SingleStudentGroup,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentIDsByStudentGroup = `-- name: ListStudentIDsByStudentGroup :many
SELECT student_id
FROM students_groups
WHERE student_group_id = $1
`

func (q *Queries) ListStudentIDsByStudentGroup(ctx context.Context, studentGroupID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listStudentIDsByStudentGroup, studentGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var student_id pgtype.UUID
		if err := rows.Scan(&student_id); err != nil {
			return nil, err
		}
		items = append(items, student_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCourseClassroom = `-- name: RemoveCourseClassroom :exec
DELETE FROM courses_classrooms
WHERE course_id = $1 AND classroom_id = $2
`

type RemoveCourseClassroomParams struct {
	CourseID    pgtype.UUID `db:"course_id" json:"course_id"`
	ClassroomID pgtype.UUID `db:"classroom_id" json:"classroom_id"`
}

func (q *Queries) RemoveCourseClassroom(ctx context.Context, arg RemoveCourseClassroomParams) error {
	_, err := q.db.Exec(ctx, removeCourseClassroom, arg.CourseID, arg.ClassroomID)
	return err
}

const removeCourseStudentGroup = `-- name: RemoveCourseStudentGroup :exec
DELETE FROM courses_student_groups
WHERE course_id = $1 AND student_group_id = $2
`

type RemoveCourseStudentGroupParams struct {
	CourseID       pgtype.UUID `db:"course_id" json:"course_id"`
	StudentGroupID pgtype.UUID `db:"student_group_id" json:"student_group_id"`
}

func (q *Queries) RemoveCourseStudentGroup(ctx context.Context, arg RemoveCourseStudentGroupParams) error {
	_, err := q.db.Exec(ctx, removeCourseStudentGroup, arg.CourseID, arg.StudentGroupID)
	return err
}

const removeCourseTeacher = `-- name: RemoveCourseTeacher :exec
DELETE FROM teachers_courses
WHERE teacher_id = $1 AND course_id = $2
`

type RemoveCourseTeacherParams struct {
	TeacherID pgtype.UUID `db:"teacher_id" json:"teacher_id"`
	CourseID  pgtype.UUID `db:"course_id" json:"course_id"`
}

func (q *Queries) RemoveCourseTeacher(ctx context.Context, arg RemoveCourseTeacherParams) error {
	_, err := q.db.Exec(ctx, removeCourseTeacher, arg.TeacherID, arg.CourseID)
	return err
}

const removeStudentGroupMember = `-- name: RemoveStudentGroupMember :exec
DELETE FROM students_groups
WHERE student_group_id = $1 AND student_id = $2
`

type RemoveStudentGroupMemberParams struct {
	StudentGroupID pgtype.UUID `db:"student_group_id" json:"student_group_id"`
	StudentID      pgtype.UUID `db:"student_id" json:"student_id"`
}

func (q *Queries) RemoveStudentGroupMember(ctx context.Context, arg RemoveStudentGroupMemberParams) error {
	_, err := q.db.Exec(ctx, removeStudentGroupMember, arg.StudentGroupID, arg.StudentID)
	return err
}

const softDeleteClassroom = `-- name: SoftDeleteClassroom :exec
UPDATE classrooms
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type SoftDeleteClassroomParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) SoftDeleteClassroom(ctx context.Context, arg SoftDeleteClassroomParams) error {
	_, err := q.db.Exec(ctx, softDeleteClassroom, arg.ID, arg.DeletedAt)
	return err
}

const softDeleteCourse = `-- name: SoftDeleteCourse :exec
UPDATE courses
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type SoftDeleteCourseParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) SoftDeleteCourse(ctx context.Context, arg SoftDeleteCourseParams) error {
	_, err := q.db.Exec(ctx, softDeleteCourse, arg.ID, arg.DeletedAt)
	return err
}

const softDeleteSchool = `-- name: SoftDeleteSchool :exec
UPDATE schools
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type SoftDeleteSchoolParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) SoftDeleteSchool(ctx context.Context, arg SoftDeleteSchoolParams) error {
	_, err := q.db.Exec(ctx, softDeleteSchool, arg.ID, arg.DeletedAt)
	return err
}

const softDeleteSchoolPreferences = `-- name: SoftDeleteSchoolPreferences :exec
UPDATE school_preferences
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type SoftDeleteSchoolPreferencesParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) SoftDeleteSchoolPreferences(ctx context.Context, arg SoftDeleteSchoolPreferencesParams) error {
	_, err := q.db.Exec(ctx, softDeleteSchoolPreferences, arg.ID, arg.DeletedAt)
	return err
}

const softDeleteStudentGroup = `-- name: SoftDeleteStudentGroup :exec
UPDATE student_groups
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type SoftDeleteStudentGroupParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) SoftDeleteStudentGroup(ctx context.Context, arg SoftDeleteStudentGroupParams) error {
	_, err := q.db.Exec(ctx, softDeleteStudentGroup, arg.ID, arg.DeletedAt)
	return err
}

const updateClassroom = `-- name: UpdateClassroom :one
UPDATE classrooms
SET name = $2,
    updated_at = $3
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, school_id, name, created_at, updated_at, deleted_at
`

type UpdateClassroomParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateClassroom(ctx context.Context, arg UpdateClassroomParams) (Classroom, error) {
	row := q.db.QueryRow(ctx, updateClassroom, arg.ID, arg.Name, arg.UpdatedAt)
	var i Classroom
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCourse = `-- name: UpdateCourse :one
UPDATE courses
SET name = $2,
    start_at = $3,
    end_at = $4,
    is_online = $5,
    signature_closing_delay_minutes = $6,
    signature_closed = $7,
    updated_at = $8
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, school_id, name, start_at, end_at, is_online, signature_closing_delay_minutes, signature_closed, created_at, updated_at, deleted_at
`

type UpdateCourseParams struct {
	ID                           pgtype.UUID        `db:"id" json:"id"`
	Name                         string             `db:"name" json:"name"`
	StartAt                      pgtype.Timestamptz `db:"start_at" json:"start_at"`
	EndAt                        pgtype.Timestamptz `db:"end_at" json:"end_at"`
	IsOnline                     bool               `db:"is_online" json:"is_online"`
	SignatureClosingDelayMinutes int32              `db:"signature_closing_delay_minutes" json:"signature_closing_delay_minutes"`
	SignatureClosed              bool               `db:"signature_closed" json:"signature_closed"`
	UpdatedAt                    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, updateCourse,
		arg.ID,
		arg.Name,
		arg.StartAt,
		arg.EndAt,
		arg.IsOnline,
		arg.SignatureClosingDelayMinutes,
		arg.SignatureClosed,
		arg.UpdatedAt,
	)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.StartAt,
		&i.EndAt,
		&i.IsOnline,
		&i.SignatureClosingDelayMinutes,
		&i.SignatureClosed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSchool = `-- name: UpdateSchool :one
UPDATE schools
SET name = $2,
    updated_at = $3
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, preferences_id, created_at, updated_at, deleted_at
`

type UpdateSchoolParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateSchool(ctx context.Context, arg UpdateSchoolParams) (School, error) {
	row := q.db.QueryRow(ctx, updateSchool, arg.ID, arg.Name, arg.UpdatedAt)
	var i School
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PreferencesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSchoolPreferences = `-- name: UpdateSchoolPreferences :one
UPDATE school_preferences
SET default_signature_closing_delay_minutes = $2,
    teacher_can_modify_closing_delay = $3,
    students_can_sign_before_teacher = $4,
    enable_flash = $5,
    enable_qrcode = $6,
    enable_nfc = $7,
    updated_at = $8
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, default_signature_closing_delay_minutes, teacher_can_modify_closing_delay, students_can_sign_before_teacher, enable_flash, enable_qrcode, enable_nfc, created_at, updated_at, deleted_at
`

type UpdateSchoolPreferencesParams struct {
	ID                                  pgtype.UUID        `db:"id" json:"id"`
	DefaultSignatureClosingDelayMinutes int32              `db:"default_signature_closing_delay_minutes" json:"default_signature_closing_delay_minutes"`
	TeacherCanModifyClosingDelay        bool               `db:"teacher_can_modify_closing_delay" json:"teacher_can_modify_closing_delay"`
	StudentsCanSignBeforeTeacher        bool               `db:"students_can_sign_before_teacher" json:"students_can_sign_before_teacher"`
	EnableFlash                         bool               `db:"enable_flash" json:"enable_flash"`
	EnableQrcode                        bool               `db:"enable_qrcode" json:"enable_qrcode"`
	EnableNfc                           bool               `db:"enable_nfc" json:"enable_nfc"`
	UpdatedAt                           pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateSchoolPreferences(ctx context.Context, arg UpdateSchoolPreferencesParams) (SchoolPreference, error) {
	row := q.db.QueryRow(ctx, updateSchoolPreferences,
		arg.ID,
		arg.DefaultSignatureClosingDelayMinutes,
		arg.TeacherCanModifyClosingDelay,
		arg.StudentsCanSignBeforeTeacher,
		arg.EnableFlash,
		arg.EnableQrcode,
		arg.EnableNfc,
		arg.UpdatedAt,
	)
	var i SchoolPreference
	err := row.Scan(
		&i.ID,
		&i.DefaultSignatureClosingDelayMinutes,
		&i.TeacherCanModifyClosingDelay,
		&i.StudentsCanSignBeforeTeacher,
		&i.EnableFlash,
		&i.EnableQrcode,
		&i.EnableNfc,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateStudentGroup = `-- name: UpdateStudentGroup :one
UPDATE student_groups
SET name = $2,
    single_student_group = $3,
    updated_at = $4
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, school_id, name, single_student_group, created_at, updated_at, deleted_at
`

type UpdateStudentGroupParams struct {
	ID                 pgtype.UUID        `db:"id" json:"id"`
	Name               string             `db:"name" json:"name"`
	SingleStudentGroup bool               `db:"single_student_group" json:"single_student_group"`
	UpdatedAt          pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateStudentGroup(ctx context.Context, arg UpdateStudentGroupParams) (StudentGroup, error) {
	row := q.db.QueryRow(ctx, updateStudentGroup,
		arg.ID,
		arg.Name,
		arg.SingleStudentGroup,
		arg.UpdatedAt,
	)
	var i StudentGroup
	err := row.Scan(
		&i.ID,
		&i.SchoolID,
		&i.Name,
		&i.SingleStudentGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const validateClassroomCourse = `-- name: ValidateClassroomCourse :one
SELECT EXISTS (
  SELECT 1
  FROM courses_classrooms
  WHERE classroom_id = $1 AND course_id = $2
) AS is_linked
`

type ValidateClassroomCourseParams struct {
	ClassroomID pgtype.UUID `db:"classroom_id" json:"classroom_id"`
	CourseID    pgtype.UUID `db:"course_id" json:"course_id"`
}

func (q *Queries) ValidateClassroomCourse(ctx context.Context, arg ValidateClassroomCourseParams) (bool, error) {
	row := q.db.QueryRow(ctx, validateClassroomCourse, arg.ClassroomID, arg.CourseID)
	var is_linked bool
	err := row.Scan(&is_linked)
	return is_linked, err
}

const validateStudentCourse = `-- name: ValidateStudentCourse :one
SELECT EXISTS (
  SELECT 1
  FROM courses_student_groups csg
  INNER JOIN students_groups sg ON sg.student_group_id = csg.student_group_id
  WHERE sg.student_id = $1 AND csg.course_id = $2
) AS is_allowed
`

type ValidateStudentCourseParams struct {
	StudentID pgtype.UUID `db:"student_id" json:"student_id"`
	CourseID  pgtype.UUID `db:"course_id" json:"course_id"`
}

func (q *Queries) ValidateStudentCourse(ctx context.Context, arg ValidateStudentCourseParams) (bool, error) {
	row := q.db.QueryRow(ctx, validateStudentCourse, arg.StudentID, arg.CourseID)
	var is_allowed bool
	err := row.Scan(&is_allowed)
	return is_allowed, err
}

const validateTeacherCourse = `-- name: ValidateTeacherCourse :one
SELECT EXISTS (
  SELECT 1
  FROM teachers_courses
  WHERE teacher_id = $1 AND course_id = $2
) AS is_assigned
`

type ValidateTeacherCourseParams struct {
	TeacherID pgtype.UUID `db:"teacher_id" json:"teacher_id"`
	CourseID  pgtype.UUID `db:"course_id" json:"course_id"`
}

func (q *Queries) ValidateTeacherCourse(ctx context.Context, arg ValidateTeacherCourseParams) (bool, error) {
	row := q.db.QueryRow(ctx, validateTeacherCourse, arg.TeacherID, arg.CourseID)
	var is_assigned bool
	err := row.Scan(&is_assigned)
	return is_assigned, err
}
